<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nclist-cpp: nclist/overlaps_start.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nclist-cpp
   </div>
   <div id="projectbrief">C++ implementation of nested containment lists</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_9176ee8b13bdf52351c6107864f7b03e.html">nclist</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="headertitle"><div class="title">overlaps_start.hpp</div></div>
</div><!--header-->
<div class="contents">
<a href="overlaps__start_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="preprocessor">#ifndef NCLIST_OVERLAPS_START_HPP</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="preprocessor">#define NCLIST_OVERLAPS_START_HPP</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span> </div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="preprocessor">#include &lt;optional&gt;</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="preprocessor">#include &lt;limits&gt;</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span> </div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="preprocessor">#include &quot;<a class="code" href="build_8hpp.html">build.hpp</a>&quot;</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="preprocessor">#include &quot;utils.hpp&quot;</span></div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span> </div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacenclist.html">nclist</a> {</div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span> </div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Index_&gt;</div>
<div class="foldopen" id="foldopen00027" data-start="{" data-end="};">
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno"><a class="line" href="structnclist_1_1OverlapsStartWorkspace.html">   27</a></span><span class="keyword">struct </span><a class="code hl_struct" href="structnclist_1_1OverlapsStartWorkspace.html">OverlapsStartWorkspace</a> {</div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span>    <span class="keyword">struct </span>State {</div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span>        State() = <span class="keywordflow">default</span>;</div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span>        State(Index_ cat, Index_ cend, <span class="keywordtype">bool</span> skip) : child_at(cat), child_end(cend), skip_search(skip) {}</div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span>        Index_ child_at = 0, child_end = 0;</div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span>        <span class="keywordtype">bool</span> skip_search = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span>    };</div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span>    std::vector&lt;State&gt; history;</div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span>};</div>
</div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span> </div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Position_&gt;</div>
<div class="foldopen" id="foldopen00048" data-start="{" data-end="};">
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno"><a class="line" href="structnclist_1_1OverlapsStartParameters.html">   48</a></span><span class="keyword">struct </span><a class="code hl_struct" href="structnclist_1_1OverlapsStartParameters.html">OverlapsStartParameters</a> {</div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno"><a class="line" href="structnclist_1_1OverlapsStartParameters.html#aaf56a28fba57e919f94088408bc03eb4">   53</a></span>    Position_ <a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#aaf56a28fba57e919f94088408bc03eb4">max_gap</a> = 0;</div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span> </div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno"><a class="line" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">   59</a></span>    Position_ <a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">min_overlap</a> = 0;</div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span> </div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno"><a class="line" href="structnclist_1_1OverlapsStartParameters.html#a26b33e5a64909962350b7369cd431dcf">   65</a></span>    <span class="keywordtype">bool</span> <a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a26b33e5a64909962350b7369cd431dcf">quit_on_first</a> = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span>};</div>
</div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span> </div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Index_, <span class="keyword">typename</span> Position_&gt;</div>
<div class="foldopen" id="foldopen00084" data-start="{" data-end="}">
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno"><a class="line" href="namespacenclist.html#aebdbb3bf7c28aad8d1237d030a6c97f6">   84</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="namespacenclist.html#aebdbb3bf7c28aad8d1237d030a6c97f6">overlaps_start</a>(</div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno">   85</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structnclist_1_1Nclist.html">Nclist&lt;Index_, Position_&gt;</a>&amp; subject,</div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span>    Position_ query_start,</div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno">   87</span>    Position_ query_end,</div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno">   88</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structnclist_1_1OverlapsStartParameters.html">OverlapsStartParameters&lt;Position_&gt;</a>&amp; params,</div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span>    <a class="code hl_struct" href="structnclist_1_1OverlapsStartWorkspace.html">OverlapsStartWorkspace&lt;Index_&gt;</a>&amp; workspace,</div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span>    std::vector&lt;Index_&gt;&amp; matches)</div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span>{</div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span>    matches.clear();</div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span>    <span class="keywordflow">if</span> (subject.root_children == 0) {</div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span>    }</div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span> </div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span><span class="comment">    /****************************************</span></div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span><span class="comment">     * # Default</span></div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span><span class="comment">     *</span></div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span><span class="comment">     * Our aim is to find overlaps to a subject interval `i` where `subject_start[i] == query_start`. </span></div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno">  101</span><span class="comment">     *</span></div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno">  102</span><span class="comment">     * At each node of the NCList, we search for the first child where the `subject_ends` is greater than or equal to `query_start`. </span></div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span><span class="comment">     * Earlier &quot;sibling&quot; intervals must have earlier start positions that cannot be equal to that of the query interval - nor can their children.</span></div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span><span class="comment">     * We do so using a binary search (std::lower_bound) on `subject_ends` - recall that these are sorted for children of each node.</span></div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span><span class="comment">     *</span></div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span><span class="comment">     * We then iterate until the first interval `j` where `query_start &lt; subject_starts[j]`, at which point we stop.</span></div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span><span class="comment">     * None of `j`, the children of `j`, nor any sibling intervals after `j` can have a start position equal to the query interval, so there&#39;s no point in traversing those nodes. </span></div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span><span class="comment">     * Any subject interval encountered during this iteration with an equal start position to the query is reported in `matches`.</span></div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span><span class="comment">     * Regardless of whether the start position is equal, we repeat the search on the children of all subject intervals encountered during iteration, as one of them might have an equal start position.</span></div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span><span class="comment">     *</span></div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span><span class="comment">     * For a modest efficiency boost, we consider the case where `query_start &lt;= subject_starts[i]` for node `i`.</span></div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span><span class="comment">     * In such cases, `subject_ends` for all children of `i` must also satisfy `query_start &lt;= subject_ends[i]`, in which case the binary search can be skipped.</span></div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span><span class="comment">     * Moreover, all descendent intervals of `i` must end after `query_start`, so the binary search can be skipped for the entire lineage of the NCList.</span></div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span><span class="comment">     *</span></div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span><span class="comment">     * # Max gap</span></div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno">  116</span><span class="comment">     *</span></div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno">  117</span><span class="comment">     * Here, our aim is to find subject intervals where `abs(query_start - subject_starts[i]) &lt;= max_gap`.</span></div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno">  118</span><span class="comment">     * This follows much the same logic as in the default case with some adjustments:</span></div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno">  119</span><span class="comment">     *</span></div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span><span class="comment">     * - We consider an &quot;effective&quot; query start as `effective_query_start = query_start - max_gap`.</span></div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span><span class="comment">     * - We then perform a binary search to find the first `subject_ends` that is greater than or equal to `effective_query_start`.</span></div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span><span class="comment">     *   This is the earlier subject interval that has a start position (or has children with a start position) within `max_gap` of the query start.</span></div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span><span class="comment">     * - Similarly, we check if `effective_query_start &lt;= subject_starts[i]` to determine whether to skip the binary search.</span></div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span><span class="comment">     * - We stop iteration once `subject_starts[j] - query_start &gt; max_gap`, after which we know that all start positions of siblings/children must lie beyond `max_gap`.</span></div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span><span class="comment">     * - Any subject interval encountered during this iteration with a start position that satisfies `max_gap` is reported in `matches`.</span></div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span><span class="comment">     *</span></div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span><span class="comment">     * # Min overlap</span></div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span><span class="comment">     *</span></div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno">  129</span><span class="comment">     * Here, we apply the extra restriction that the overlapping subinterval must have length greater than `min_overlap`.</span></div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno">  130</span><span class="comment">     * This follows the same logic as the default case, with some modifications:</span></div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span><span class="comment">     *</span></div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span><span class="comment">     * - We consider an &quot;effective&quot; query start as `effective_query_start = query_start + min_overlap`.</span></div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span><span class="comment">     *   This defines the earliest entry of `subject_ends` that still could provide an overlap of at least `min_overlap`.</span></div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span><span class="comment">     * - We perform a binary search to find the first `subject_ends` that is greater than or equal to `effective_query_start`.</span></div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span><span class="comment">     * - Similarly, we check if `effective_query_start &lt;= subject_starts[i]` to determine whether to skip the binary search.</span></div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span><span class="comment">     * - We stop iteration once `query_end - subject_starts[j] &lt; min_overlap`, after which we know that all children cannot achieve `min_overlap`.</span></div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span><span class="comment">     * - If the length of the overlapping subinterval is less than `min_overlap`, we do not report the subject interval in `matches`.</span></div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span><span class="comment">     *   Additionally, we skip traversal of that node&#39;s children, as the children must be smaller and will not satisfy `min_overlap` anyway. </span></div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span><span class="comment">     *</span></div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span><span class="comment">     * We return early if the length of the query itself is less than `min_overlap`, as no overlap will be satisfactory.</span></div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno">  141</span><span class="comment">     *</span></div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span><span class="comment">     * Note that we do not use an effective query end for the binary search.</span></div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno">  143</span><span class="comment">     * The comparison between query/subject ends doesn&#39;t say anything about the length of the overlap subinterval.</span></div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno">  144</span><span class="comment">     *</span></div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno">  145</span><span class="comment">     * These modifications are mostly orthogonal to those required when `max_gap &gt; 0`, so can be combined without much effort. </span></div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno">  146</span><span class="comment">     * We stop iterations when either of the stopping criteria for `max_gap` or `min_overlap` are satisfied.</span></div>
<div class="line"><a id="l00147" name="l00147"></a><span class="lineno">  147</span><span class="comment">     * For the effective query start, the definition from `min_overlaps` will take precedence as it is more stringent, i.e., restricts more of the search space.</span></div>
<div class="line"><a id="l00148" name="l00148"></a><span class="lineno">  148</span><span class="comment">     *</span></div>
<div class="line"><a id="l00149" name="l00149"></a><span class="lineno">  149</span><span class="comment">     ****************************************/</span></div>
<div class="line"><a id="l00150" name="l00150"></a><span class="lineno">  150</span> </div>
<div class="line"><a id="l00151" name="l00151"></a><span class="lineno">  151</span>    <span class="keywordflow">if</span> (params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">min_overlap</a> &gt; 0) {</div>
<div class="line"><a id="l00152" name="l00152"></a><span class="lineno">  152</span>        <span class="keywordflow">if</span> (query_end - query_start &lt; params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">min_overlap</a>) {</div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span>            <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno">  154</span>        }</div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span>    }</div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span> </div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span>    Position_ effective_query_start = query_start;</div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno">  158</span>    <span class="keywordflow">if</span> (params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">min_overlap</a> &gt; 0) {</div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno">  159</span>        <span class="keyword">constexpr</span> Position_ maxed = std::numeric_limits&lt;Position_&gt;::max();</div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno">  160</span>        <span class="keywordflow">if</span> (maxed - params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">min_overlap</a> &lt; query_start) {</div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno">  161</span>            <span class="keywordflow">return</span>; <span class="comment">// No point continuing as nothing will be found in the binary search.</span></div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span>        }</div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span>        effective_query_start = query_start + params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">min_overlap</a>;</div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#aaf56a28fba57e919f94088408bc03eb4">max_gap</a> &gt; 0) {</div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span>        effective_query_start = safe_subtract_gap(query_start, params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#aaf56a28fba57e919f94088408bc03eb4">max_gap</a>);</div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span>    }</div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span> </div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span>    <span class="keyword">auto</span> find_first_child = [&amp;](Index_ children_start, Index_ children_end) -&gt; Index_ {</div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span>        <span class="keyword">auto</span> ebegin = subject.ends.begin();</div>
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno">  170</span>        <span class="keyword">auto</span> estart = ebegin + children_start; </div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno">  171</span>        <span class="keyword">auto</span> eend = ebegin + children_end;</div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno">  172</span>        <span class="keywordflow">return</span> std::lower_bound(estart, eend, effective_query_start) - ebegin;</div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno">  173</span>    };</div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno">  174</span> </div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span>    <span class="keyword">auto</span> skip_binary_search = [&amp;](Position_ subject_start) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno">  176</span>        <span class="keywordflow">return</span> subject_start &gt;= effective_query_start;</div>
<div class="line"><a id="l00177" name="l00177"></a><span class="lineno">  177</span>    };</div>
<div class="line"><a id="l00178" name="l00178"></a><span class="lineno">  178</span> </div>
<div class="line"><a id="l00179" name="l00179"></a><span class="lineno">  179</span>    <span class="keyword">auto</span> is_finished = [&amp;](Position_ subject_start) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno">  180</span>        <span class="keywordflow">if</span> (subject_start &gt; query_start) {</div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span>            <span class="keywordflow">if</span> (params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#aaf56a28fba57e919f94088408bc03eb4">max_gap</a> == 0) {</div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span>            }</div>
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno">  184</span>            <span class="keywordflow">if</span> (subject_start - query_start &gt; params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#aaf56a28fba57e919f94088408bc03eb4">max_gap</a>) {</div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span>            }</div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno">  187</span>            <span class="keywordflow">if</span> (params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">min_overlap</a> &gt; 0) {</div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno">  188</span>                <span class="keywordflow">if</span> (subject_start &gt;= query_end || query_end - subject_start &lt; params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">min_overlap</a>) {</div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno">  189</span>                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno">  190</span>                }</div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span>            }</div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00193" name="l00193"></a><span class="lineno">  193</span>            <span class="keywordflow">if</span> (params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">min_overlap</a> &gt; 0) {</div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno">  194</span>                <span class="comment">// if query_start &gt;= subject_start, then query_end &gt;=</span></div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span>                <span class="comment">// subject_start as well, so the LHS will be non-negative.</span></div>
<div class="line"><a id="l00196" name="l00196"></a><span class="lineno">  196</span>                <span class="keywordflow">if</span> (query_end - subject_start &lt; params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">min_overlap</a>) {</div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span>                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno">  198</span>                }</div>
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno">  199</span>            }</div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno">  200</span>        }</div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno">  201</span> </div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno">  203</span>    };</div>
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno">  204</span> </div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno">  205</span>    Index_ root_child_at = 0;</div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span>    <span class="keywordtype">bool</span> root_skip_search = skip_binary_search(subject.starts[0]);</div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno">  207</span>    <span class="keywordflow">if</span> (!root_skip_search) {</div>
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno">  208</span>        root_child_at = find_first_child(0, subject.root_children);</div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno">  209</span>    }</div>
<div class="line"><a id="l00210" name="l00210"></a><span class="lineno">  210</span> </div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno">  211</span>    workspace.history.clear();</div>
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno">  212</span>    <span class="keywordflow">while</span> (1) {</div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno">  213</span>        Index_ current_subject;</div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span>        <span class="keywordtype">bool</span> skip_search;</div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span>        <span class="keywordflow">if</span> (workspace.history.empty()) {</div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno">  216</span>            <span class="keywordflow">if</span> (root_child_at == subject.root_children || is_finished(subject.starts[root_child_at])) {</div>
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno">  217</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span>            }</div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span>            current_subject = root_child_at;</div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno">  220</span>            skip_search = root_skip_search;</div>
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno">  221</span>            ++root_child_at;</div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno">  222</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno">  223</span>            <span class="keyword">auto</span>&amp; current_state = workspace.history.back();</div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span>            <span class="keywordflow">if</span> (current_state.child_at == current_state.child_end || is_finished(subject.starts[current_state.child_at])) {</div>
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno">  225</span>                workspace.history.pop_back();</div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno">  226</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span>            }</div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span>            current_subject = current_state.child_at;</div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span>            skip_search = current_state.skip_search;</div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span>            ++(current_state.child_at); <span class="comment">// do this before the emplace_back(), otherwise the history might get reallocated and the reference would be dangling.</span></div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span>        }</div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span> </div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span>        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; current_node = subject.nodes[current_subject];</div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span>        <span class="keyword">auto</span> subject_start = subject.starts[current_subject];</div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span>        <span class="keyword">auto</span> subject_end = subject.ends[current_subject];</div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span> </div>
<div class="line"><a id="l00237" name="l00237"></a><span class="lineno">  237</span>        <span class="keywordflow">if</span> (params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">min_overlap</a> &gt; 0) {</div>
<div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span>            <span class="keyword">auto</span> common_end = std::min(subject_end, query_end);</div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span>            <span class="keyword">auto</span> common_start = std::max(subject_start, query_start);</div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span>            <span class="keywordflow">if</span> (common_end &lt;= common_start || common_end - common_start &lt; params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">min_overlap</a>) {</div>
<div class="line"><a id="l00241" name="l00241"></a><span class="lineno">  241</span>                <span class="comment">// No point processing the children if the minimum overlap isn&#39;t satisified.</span></div>
<div class="line"><a id="l00242" name="l00242"></a><span class="lineno">  242</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00243" name="l00243"></a><span class="lineno">  243</span>            }</div>
<div class="line"><a id="l00244" name="l00244"></a><span class="lineno">  244</span>        }</div>
<div class="line"><a id="l00245" name="l00245"></a><span class="lineno">  245</span> </div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span>        <span class="comment">// Even if the current subject interval isn&#39;t a match, its children might still be okay, so we have to keep going.</span></div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno">  247</span>        <span class="keywordtype">bool</span> okay;</div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span>        <span class="keywordflow">if</span> (params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#aaf56a28fba57e919f94088408bc03eb4">max_gap</a> &gt; 0) {</div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span>            okay = !diff_above_gap(query_start, subject_start, params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#aaf56a28fba57e919f94088408bc03eb4">max_gap</a>);</div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span>            okay = (subject_start == query_start);</div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span>        }</div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span>        <span class="keywordflow">if</span> (okay) {</div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span>            matches.push_back(current_node.id);</div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span>            <span class="keywordflow">if</span> (params.<a class="code hl_variable" href="structnclist_1_1OverlapsStartParameters.html#a26b33e5a64909962350b7369cd431dcf">quit_on_first</a>) {</div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span>                <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span>            }</div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span>            <span class="keywordflow">if</span> (current_node.duplicates_start != current_node.duplicates_end) {</div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span>                matches.insert(matches.end(), subject.duplicates.begin() + current_node.duplicates_start, subject.duplicates.begin() + current_node.duplicates_end);</div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span>            }</div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span>        }</div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span> </div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span>        <span class="keywordflow">if</span> (current_node.children_start != current_node.children_end) {</div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span>            <span class="keywordflow">if</span> (skip_search) {</div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno">  265</span>                workspace.history.emplace_back(current_node.children_start, current_node.children_end, <span class="keyword">true</span>);</div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno">  266</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno">  267</span>                Index_ start_pos = find_first_child(current_node.children_start, current_node.children_end);</div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno">  268</span>                <span class="keywordflow">if</span> (start_pos != current_node.children_end) {</div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span>                    workspace.history.emplace_back(start_pos, current_node.children_end, skip_binary_search(subject.starts[start_pos]));</div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno">  270</span>                }</div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span>            }</div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span>        }</div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span>    }</div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno">  274</span>}</div>
</div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span> </div>
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno">  276</span>}</div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span> </div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span><span class="preprocessor">#endif</span></div>
<div class="ttc" id="abuild_8hpp_html"><div class="ttname"><a href="build_8hpp.html">build.hpp</a></div><div class="ttdoc">Build a nested containment list.</div></div>
<div class="ttc" id="anamespacenclist_html"><div class="ttname"><a href="namespacenclist.html">nclist</a></div><div class="ttdoc">Header-only library for nested containment lists.</div><div class="ttdef"><b>Definition</b> build.hpp:16</div></div>
<div class="ttc" id="anamespacenclist_html_aebdbb3bf7c28aad8d1237d030a6c97f6"><div class="ttname"><a href="namespacenclist.html#aebdbb3bf7c28aad8d1237d030a6c97f6">nclist::overlaps_start</a></div><div class="ttdeci">void overlaps_start(const Nclist&lt; Index_, Position_ &gt; &amp;subject, Position_ query_start, Position_ query_end, const OverlapsStartParameters&lt; Position_ &gt; &amp;params, OverlapsStartWorkspace&lt; Index_ &gt; &amp;workspace, std::vector&lt; Index_ &gt; &amp;matches)</div><div class="ttdef"><b>Definition</b> overlaps_start.hpp:84</div></div>
<div class="ttc" id="astructnclist_1_1Nclist_html"><div class="ttname"><a href="structnclist_1_1Nclist.html">nclist::Nclist</a></div><div class="ttdoc">Pre-built nested containment list.</div><div class="ttdef"><b>Definition</b> build.hpp:27</div></div>
<div class="ttc" id="astructnclist_1_1OverlapsStartParameters_html"><div class="ttname"><a href="structnclist_1_1OverlapsStartParameters.html">nclist::OverlapsStartParameters</a></div><div class="ttdoc">Parameters for overlaps_start().</div><div class="ttdef"><b>Definition</b> overlaps_start.hpp:48</div></div>
<div class="ttc" id="astructnclist_1_1OverlapsStartParameters_html_a0522dd6f35f283fc8638a9d20a88da8e"><div class="ttname"><a href="structnclist_1_1OverlapsStartParameters.html#a0522dd6f35f283fc8638a9d20a88da8e">nclist::OverlapsStartParameters::min_overlap</a></div><div class="ttdeci">Position_ min_overlap</div><div class="ttdef"><b>Definition</b> overlaps_start.hpp:59</div></div>
<div class="ttc" id="astructnclist_1_1OverlapsStartParameters_html_a26b33e5a64909962350b7369cd431dcf"><div class="ttname"><a href="structnclist_1_1OverlapsStartParameters.html#a26b33e5a64909962350b7369cd431dcf">nclist::OverlapsStartParameters::quit_on_first</a></div><div class="ttdeci">bool quit_on_first</div><div class="ttdef"><b>Definition</b> overlaps_start.hpp:65</div></div>
<div class="ttc" id="astructnclist_1_1OverlapsStartParameters_html_aaf56a28fba57e919f94088408bc03eb4"><div class="ttname"><a href="structnclist_1_1OverlapsStartParameters.html#aaf56a28fba57e919f94088408bc03eb4">nclist::OverlapsStartParameters::max_gap</a></div><div class="ttdeci">Position_ max_gap</div><div class="ttdef"><b>Definition</b> overlaps_start.hpp:53</div></div>
<div class="ttc" id="astructnclist_1_1OverlapsStartWorkspace_html"><div class="ttname"><a href="structnclist_1_1OverlapsStartWorkspace.html">nclist::OverlapsStartWorkspace</a></div><div class="ttdoc">Workspace for overlaps_start().</div><div class="ttdef"><b>Definition</b> overlaps_start.hpp:27</div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
